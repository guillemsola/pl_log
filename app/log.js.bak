var fs = require('fs');
var moment = require('moment');

var debug = function(message) {
	console.log(message);
};

var data = {
	pipeline: '',
	pipelineId: '',
	steps: [],
	rollbackSteps: [],
	start: '',
	end: ''
};

function Step(order) {
	this.order = order,
	this.command = {},
	this.messages = [],
	this.start = '',
	this.end = '',

	this.addLog = function (message) {
		this.messages.push(message);
	}
}

var currentStep;

var splitRgx = /"(.*?)[";?]/;

function readLines(fileName, func) {
	var input = fs.createReadStream(fileName);
	var remaining = '';

	input.on('data', function(data) {
		remaining += data;
    	var index = remaining.indexOf('\n');
		while (index > -1) {
			var line = remaining.substring(0, index);
			remaining = remaining.substring(index + 1);
			func(line);
			index = remaining.indexOf('\n');
    	}
	});

	input.on('end', function() {
		if(remaining.length > 0) {
			func(remaining);
		}

		fs.writeFile('outcome.json', JSON.stringify(data, null, 4), function(err) {
		    if(err) {
		      console.log(err);
		    } else {
		      console.log("JSON saved");
		    }
		}); 	
	});
}

function processLine(line) {
	var fields = line.split( /"(.*?)";?/g );

	var entry = {
    	time: moment(fields[1], 'DD/MM/YYYY, HH:mm:ss:SSS').format(),
    	level: fields[3],
    	message: fields[5],
    	details: fields[7],
    	type: fields[9]
    };
    //console.log('--- ' + entry.message);

    if( /Begin execution pipeline.*/.test(entry.message)) {
    	debug('Detected pipeline');
    	//data.pipelineId = entry.message.substring(26, 58);
    	data.pipelineId = entry.message.split( /([0-9A-F]{32})/ )[1];
    	data.pipeline = entry.message.split( /from type: (.*);$/ )[1];
    	data.start = entry.time;
    }
    else if( /Begin execution step.*/.test(entry.message)) {
    	debug('Detected new step');
    	currentStep = new Step();
    	currentStep.start = entry.time;
    	currentStep.order = entry.message.split( /with order: ([0-9]*)$/)[1];
    	// TODO get step number order
    }
    else if( /End step \d+ execution.*/.test(entry.message)) {
    	debug('End of step.')
    	if(currentStep !== undefined) {
    		currentStep.end = entry.time;
    		data.steps.push(currentStep);
    	};
    }
    else if( /Command: .+/.test(entry.message)) {
    	currentStep.command = entry.message.split( /Name: (.*)$/ )[1];
    }
    else if( entry.message === 'MESSAGE') {
    	debug('Skipping header');
    }
    else if( /Begin rollback.*/.test(entry.message)) {
    	debug('Detected rollback steps');
    	currentStep = new Step();
    	currentStep.start = entry.time;
    	currentStep.order = entry.message.split( /Order: ([0-9]*)$/)[1];
    }
    else if( /End rollback.*/.test(entry.message)) {
    	debug('End of rollback step.')
    	if(currentStep !== undefined) {
    		currentStep.end = entry.time;
    		data.rollbackSteps.push(currentStep);
    	};	
    }
    else if(currentStep !== undefined) {
    	currentStep.addLog(entry.message)
    };
    // Identify Command
    // Identify command parameters

    // data.steps.push(entry);
}

debug('Start!');
readLines('log.csv', processLine);
